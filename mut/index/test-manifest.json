{
    "url": "www.mongodb.com/docs/test",
    "includeInGlobalSearch": false,
    "documents": [
        {
            "slug": "implement this later",
            "title": "Aggregation Commands",
            "headings": [],
            "paragraphs": "For a detailed comparison of the different approaches, see\nAggregation Commands Comparison.For details on specific commands, including syntax and examples,\nclick on the specific command to go to its reference page.NameDescriptionaggregatePerforms aggregation tasks such as $group using an aggregation pipeline.countCounts the number of documents in a collection or a view.distinctDisplays the distinct values found for a specified key in a collection or a view.mapReducePerforms map-reduce aggregation for large data sets.",
            "code": [],
            "preview": "implement this later",
            "tags": null
        },
        {
            "slug": "implement this later",
            "title": "db.collection.updateOne()",
            "headings": [
                "Definition",
                "Syntax",
                "Parameters",
                "Returns",
                "Access Control",
                "Behavior",
                "Updates a Single Document",
                "Update with an Update Operator Expressions Document",
                "Update with an Aggregation Pipeline",
                "Upsert",
                "Capped Collection",
                "Sharded Collections",
                "upsert",
                " on a Sharded Collection",
                "Shard Key Modification",
                "Missing Shard Key",
                "Explainability",
                "Transactions",
                "Upsert within Transactions",
                "Write Concerns and Transactions",
                "Examples",
                "Update using Update Operator Expressions",
                "Update with Aggregation Pipeline",
                "Example 1",
                "Example 2",
                "Update with Upsert",
                "Update with Write Concern",
                "Specify Collation",
                "Specify ",
                "arrayFilters",
                " for an Array Update Operations",
                "Update Elements Match ",
                "arrayFilters",
                " Criteria",
                "Update Specific Elements of an Array of Documents",
                "Specify ",
                "hint",
                " for Update Operations"
            ],
            "paragraphs": "Updates a single document within the collection based on the filter.This is a mongosh method. This is not the\ndocumentation for Node.js or other programming language specific\ndriver methods.In most cases, mongosh methods work the same way as\nthe legacy mongo shell methods. However, some legacy\nmethods are unavailable in mongosh.For the legacy mongo shell documentation, refer to the\ndocumentation for the corresponding MongoDB Server release:For MongoDB API drivers, refer to the language specific\nMongoDB driver documentation.mongo shell v4.4mongo shell v4.2mongo shell v4.0The updateOne() method has the following syntax:The db.collection.updateOne() method takes the following\nparameters:ParameterTypeDescriptionfilterdocumentThe selection criteria for the update. The same query\nselectors as in the find() method are available.Specify an empty document { } to update the first document returned in\nthe collection.updatedocument or pipelineThe modifications to apply. Can be one of the following:To update with a replacement document, see\ndb.collection.replaceOne().Update documentContains only update operator expressions.For more information, see\nUpdate with an Update Operator Expressions DocumentAggregation pipeline\n(Starting in MongoDB 4.2)Contains only the following aggregation stages:For more information, see\nUpdate with an Aggregation Pipeline.$addFields and its alias $set$project and its alias $unset$replaceRoot and its alias $replaceWith.upsertbooleanOptional. When true, updateOne() either:To avoid multiple upserts, ensure that the\nfilter field(s) are uniquely indexed.Defaults to false, which does not insert a new document when no\nmatch is found.Creates a new document if no documents match the filter.\nFor more details see upsert behavior.Updates a single document that matches the filter.writeConcerndocumentOptional. A document expressing the write concern. Omit to use the default write concern.Do not explicitly set the write concern for the operation if run in\na transaction. To use write concern with transactions, see\nTransactions and Write Concern.collationdocumentOptional.Specifies the collation  to use for the operation.If the collation is unspecified but the collection has a\ndefault collation (see db.createCollection()), the\noperation uses the collation specified for the collection.Collation allows users to specify\nlanguage-specific rules for string comparison, such as rules for\nlettercase and accent marks.The collation option has the following syntax:When specifying collation, the locale field is mandatory; all\nother collation fields are optional. For descriptions of the fields,\nsee Collation Document.If no collation is specified for the collection or for the\noperations, MongoDB uses the simple binary comparison used in prior\nversions for string comparisons.You cannot specify multiple collations for an operation. For\nexample, you cannot specify different collations per field, or if\nperforming a find with a sort, you cannot use one collation for the\nfind and another for the sort.arrayFiltersarrayOptional. An array of filter documents that determine which array elements to\nmodify for an update operation on an array field.For examples, see Specify arrayFilters for an Array Update Operations.In the update document, use the $[<identifier>] filtered\npositional operator to define an identifier, which you then reference\nin the array filter documents. You cannot have an array filter\ndocument for an identifier if the identifier is not included in the\nupdate document.You can include the same identifier multiple times in the update\ndocument; however, for each distinct identifier ($[identifier])\nin the update document, you must specify exactly one\ncorresponding array filter document. That is, you cannot specify\nmultiple array filter documents for the same identifier. For\nexample, if the update statement includes the identifier x\n(possibly multiple times), you cannot specify the following for\narrayFilters that includes 2 separate filter documents for x:However, you can specify compound conditions on the same identifier\nin a single filter document, such as in the following examples:The <identifier> must begin with a lowercase letter and\ncontain only alphanumeric characters.hintDocument or stringOptional. A document or string that specifies the index to use to support the query predicate.The option can take an index specification document or the index\nname string.If you specify an index that does not exist, the operation\nerrors.For an example, see Specify hint for Update Operations.The method returns a document that contains:matchedCount containing the number of matched documentsmodifiedCount containing the number of modified documentsupsertedId containing the _id for the upserted document.A boolean acknowledged as true if the operation ran with\nwrite concern or false if write concern was disabledOn deployments running with authorization, the\nuser must have access that includes the following privileges:The built-in role readWrite provides the required\nprivileges.update action on the specified collection(s).find action on the specified collection(s).insert action on the specified collection(s) if the\noperation results in an upsert.db.collection.updateOne() finds the first document that\nmatches the filter and applies the specified\nupdate modifications.For the update specifications, the\ndb.collection.updateOne() method can accept a document that\nonly contains update operator expressions.For example:Starting in MongoDB 4.2, the db.collection.updateOne() method\ncan accept an aggregation pipeline [ <stage1>, <stage2>, ... ] that\nspecifies the modifications to perform. The pipeline can consist of\nthe following stages:Using the aggregation pipeline allows for a more expressive update\nstatement, such as expressing conditional updates based on current\nfield values or updating one field using the value of another field(s).For example:For examples, see Update with Aggregation Pipeline.$addFields and its alias $set$project and its alias $unset$replaceRoot and its alias $replaceWith.The $set and $unset used in the pipeline refers to the\naggregation stages $set and $unset\nrespectively, and not the update operators $set and $unset.If upsert: true and no documents match the filter,\ndb.collection.updateOne() creates a new\ndocument based on the filter criteria and update modifications. See\nUpdate with Upsert.If you specify upsert: true on a sharded collection, you must\ninclude the full shard key in the filter. For\nadditional db.collection.updateOne() behavior on a sharded\ncollection, see Sharded Collections.If an update operation changes the document size, the operation will fail.To use db.collection.updateOne() on a sharded collection:If you don't specify upsert: true, you must include an exact\nmatch on the _id field or target a single shard (such as by\nincluding the shard key in the filter).If you specify upsert: true, the filter\nmust include the shard key.However, starting in version 4.4, documents in a sharded collection can be\nmissing the shard key fields. To target a\ndocument that is missing the shard key, you can use the null\nequality match in conjunction with another filter condition\n(such as on the _id field). For example:To modify the existing shard key value with\ndb.collection.updateOne():See also upsert on a Sharded Collection.Starting in MongoDB 4.2, you can update a document's shard key value\nunless the shard key field is the immutable _id field. In\nMongoDB 4.2 and earlier, a document's shard key field value is\nimmutable.Starting in version 4.4, documents in sharded collections can be\nmissing the shard key fields. Take precaution to avoid accidentally\nremoving the shard key when changing a document's shard key value.You must run on a mongos. Do not\nissue the operation directly on the shard.You must run either in a transaction or as a retryable write.You must include an equality filter on the full shard key.Starting in version 4.4, documents in a sharded collection can be\nmissing the shard key fields. To use\ndb.collection.updateOne() to set the document's\nmissing shard key, you must run on a\nmongos. Do not issue the operation directly on\nthe shard.In addition, the following requirements also apply:See also:TaskRequirementsTo set to nullRequires equality filter on the full shard key if\nupsert: true.To set to a non-null valueMust be performed either inside a\ntransaction or as a\nretryable write.Requires equality filter on the full shard key if upsert:\ntrue.Since a missing key value is returned as part of a null equality\nmatch, to avoid updating a null-valued key, include additional\nquery conditions (such as on the _id field) as appropriate.upsert on a Sharded CollectionMissing Shard Key FieldsupdateOne() is not compatible with\ndb.collection.explain().db.collection.updateOne() can be used inside multi-document transactions.In most cases, multi-document transaction incurs a greater\nperformance cost over single document writes, and the\navailability of multi-document transactions should not be a\nreplacement for effective schema design. For many scenarios, the\ndenormalized data model (embedded documents and arrays) will continue to be optimal for your\ndata and use cases. That is, for many scenarios, modeling your data\nappropriately will minimize the need for multi-document\ntransactions.For additional transactions usage considerations\n(such as runtime limit and oplog size limit), see also\nProduction Considerations.Starting in MongoDB 4.4, you can create collections and indexes\ninside a multi-document transaction if the transaction is\nnot a cross-shard write transaction.Specifically, in MongoDB 4.4 and greater, db.collection.updateOne() with\nupsert: true can be run on an existing collection or a\nnon-existing collection. If run on a non-existing collection,\nthe operation creates the collection.In MongoDB 4.2 and earlier, the operation must be run on an existing\ncollection.Create Collections and Indexes In a TransactionDo not explicitly set the write concern for the operation if run in\na transaction. To use write concern with transactions, see\nTransactions and Write Concern.The restaurant collection contains the  following documents:The following operation updates a single document where\nname: \"Central Perk Cafe\" with the violations field:The operation returns:If no matches were found, the operation instead returns:Setting upsert: true would insert the document if no match was found. See\nUpdate with UpsertStarting in MongoDB 4.2, the db.collection.updateOne() can use\nan aggregation pipeline for the update. The pipeline can consist of the\nfollowing stages:Using the aggregation pipeline allows for a more expressive update\nstatement, such as expressing conditional updates based on current\nfield values or updating one field using the value of another field(s).$addFields and its alias $set$project and its alias $unset$replaceRoot and its alias $replaceWith.The following examples uses the aggregation pipeline to modify a field\nusing the values of the other fields in the document.Create a members collection with the following documents:Assume that instead of separate misc1 and misc2 fields in the\nfirst document, you want to gather these into a comments field,\nlike the second document. The following update operation uses an\naggregation pipeline to:After the command, the collection contains the following documents:add the new comments field and set the lastUpdate field.remove the misc1 and misc2 fields for all documents in the\ncollection.The $set and $unset used in the pipeline refers to the\naggregation stages $set and $unset\nrespectively, and not the update operators $set and $unset.The $set stage:creates a new array field comments whose elements are the current\ncontent of the misc1 and misc2 fields andsets the field lastUpdate to the value of the aggregation\nvariable NOW. The aggregation variable\nNOW resolves to the current datetime value and remains\nthe same throughout the pipeline. To access aggregation\nvariables, prefix the variable with double dollar signs $$\nand enclose in quotes.The $unset stage removes the misc1 and misc2 fields.The aggregation pipeline allows the update to perform conditional\nupdates based on the current field values as well as use current field\nvalues to calculate a separate field value.For example, create a students3 collection with the following documents:The third document _id: 3 is missing the average and grade\nfields. Using an aggregation pipeline, you can update the document with\nthe calculated grade average and letter grade.After the command, the collection contains the following documents:The $set used in the pipeline refers to the aggregation stage\n$set, and not the update operators $set.The $set stage:calculates a new field average based on the average of the\ntests field. See $avg for more information on the\n$avg aggregation operator and $trunc for more\ninformation on the $trunc truncate aggregation operator.sets the field lastUpdate to the value of the aggregation\nvariable NOW. The aggregation variable\nNOW resolves to the current datetime value and remains\nthe same throughout the pipeline. To access aggregation\nvariables, prefix the variable with double dollar signs $$\nand enclose in quotes.The $set stage calculates a new field grade based on\nthe average field calculated in the previous stage. See\n$switch for more information on the $switch\naggregation operator.Updates with Aggregation PipelineThe restaurant collection contains the following documents:The following operation attempts to update the document with\nname : \"Pizza Rat's Pizzaria\", while upsert: true :Since upsert:true the document is inserted based on the filter and\nupdate criteria. The operation returns:The collection now contains the following documents:The name field was filled in using the filter criteria, while the\nupdate operators were used to create the rest of the document.The following operation updates the first document with violations that\nare greater than 10:The operation returns:The collection now contains the following documents:Since no documents matched the filter, and upsert was true,\nupdateOne() inserted the document with a generated\n_id and the update criteria only.Given a three member replica set, the following operation specifies a\nw of majority, wtimeout of 100:If the primary and at least one secondary acknowledge each write operation\nwithin 100 milliseconds, it returns:If the acknowledgement takes longer than the wtimeout limit, the following\nexception is thrown:The following table explains the possible values of\nerrInfo.writeConcern.provenance:ProvenanceDescriptionclientSuppliedThe write concern was specified in the application.customDefaultThe write concern originated from a custom defined\ndefault value. See setDefaultRWConcern.getLastErrorDefaultsThe write concern originated from the replica set's\nsettings.getLastErrorDefaults field.implicitDefaultThe write concern originated from the server in absence\nof all other write concern specifications.A collection myColl has the following documents:The following operation includes the collation\noption:Collation allows users to specify\nlanguage-specific rules for string comparison, such as rules for\nlettercase and accent marks.Starting in MongoDB 3.6, when updating an array field, you can\nspecify arrayFilters that determine which array elements to\nupdate.Create a collection students with the following documents:To modify all elements that are greater than or equal to 100 in the\ngrades array, use the filtered positional operator\n$[<identifier>] with the arrayFilters option in the\ndb.collection.updateOne() method:The operation updates the grades field of a single document, and\nafter the operation, the collection has the following documents:Create a collection students2 with the following documents:To modify the value of the mean field for all elements in the\ngrades array where the grade is greater than or equal to 85,\nuse the filtered positional operator $[<identifier>] with\nthe arrayFilters in the db.collection.updateOne() method:The operation updates the array of a single document, and after the\noperation, the collection has the following documents:Create a sample members collection with the following documents:Create the following indexes on the collection:The following update operation explicitly hints to use the index {\nstatus: 1 }:The update command returns the following:To view the indexes used, you can use the $indexStats pipeline:If you specify an index that does not exist, the operation errors.To update multiple documents, see\ndb.collection.updateMany().",
            "code": [
                {
                    "lang": "javascript",
                    "value": "db.collection.updateOne(\n   <filter>,\n   <update>,\n   {\n     upsert: <boolean>,\n     writeConcern: <document>,\n     collation: <document>,\n     arrayFilters: [ <filterdocument1>, ... ],\n     hint:  <document|string>        // Available starting in MongoDB 4.2.1\n   }\n)"
                },
                {
                    "lang": "none",
                    "value": "collation: {\n   locale: <string>,\n   caseLevel: <boolean>,\n   caseFirst: <string>,\n   strength: <int>,\n   numericOrdering: <boolean>,\n   alternate: <string>,\n   maxVariable: <string>,\n   backwards: <boolean>\n}"
                },
                {
                    "lang": "javascript",
                    "value": "// INVALID\n\n[\n  { \"x.a\": { $gt: 85 } },\n  { \"x.b\": { $gt: 80 } }\n]"
                },
                {
                    "lang": "javascript",
                    "value": "// Example 1\n[\n  { $or: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] }\n]\n// Example 2\n[\n  { $and: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] }\n]\n// Example 3\n[\n  { \"x.a\": { $gt: 85 }, \"x.b\": { $gt: 80 } }\n]"
                },
                {
                    "lang": "javascript",
                    "value": "db.collection.updateOne(\n   <query>,\n   { $set: { status: \"D\" }, $inc: { quantity: 2 } },\n   ...\n)"
                },
                {
                    "lang": "javascript",
                    "value": "db.collection.updateOne(\n   <query>,\n   [\n      { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ] } },\n      { $unset: [ \"misc1\", \"misc2\" ] }\n   ]\n   ...\n)"
                },
                {
                    "lang": "javascript",
                    "value": "{ _id: <value>, <shardkeyfield>: null } // _id of the document missing shard key"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\" },\n{ \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 },\n{ \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 0 }"
                },
                {
                    "lang": "javascript",
                    "value": "try {\n   db.restaurant.updateOne(\n      { \"name\" : \"Central Perk Cafe\" },\n      { $set: { \"violations\" : 3 } }\n   );\n} catch (e) {\n   print(e);\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 }"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0 }"
                },
                {
                    "lang": "javascript",
                    "value": "db.members.insertMany( [\n    { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"A\", \"points\" : 2, \"misc1\" : \"note to self: confirm status\", \"misc2\" : \"Need to activate\", \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") },\n    { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, comments: [ \"reminder: ping me at 100pts\", \"Some random comment\" ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }\n] )"
                },
                {
                    "lang": "javascript",
                    "value": "db.members.updateOne(\n   { _id: 1 },\n   [\n      { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ], lastUpdate: \"$$NOW\" } },\n      { $unset: [ \"misc1\", \"misc2\" ] }\n   ]\n)"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"Modified\", \"points\" : 2, \"lastUpdate\" : ISODate(\"2020-01-23T05:21:59.321Z\"), \"comments\" : [ \"note to self: confirm status\", \"Need to activate\" ] }\n{ \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"comments\" : [ \"reminder: ping me at 100pts\", \"Some random comment\" ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }"
                },
                {
                    "lang": "javascript",
                    "value": "db.students3.insertMany( [\n   { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\" : 92, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") },\n   { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\" : 91, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") },\n   { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }\n] )"
                },
                {
                    "lang": "javascript",
                    "value": "db.students3.updateOne(\n   { _id: 3 },\n   [\n     { $set: { average: { $trunc: [  { $avg: \"$tests\" }, 0 ] }, lastUpdate: \"$$NOW\" } },\n     { $set: { grade: { $switch: {\n                           branches: [\n                               { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" },\n                               { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" },\n                               { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" },\n                               { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" }\n                           ],\n                           default: \"F\"\n     } } } }\n   ]\n)"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\" : 92, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") }\n{ \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\" : 91, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") }\n{ \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:33:30.674Z\"), \"average\" : 75, \"grade\" : \"C\" }"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 },\n{ \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 },\n{ \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : \"0\" }"
                },
                {
                    "lang": "javascript",
                    "value": "try {\n   db.restaurant.updateOne(\n      { \"name\" : \"Pizza Rat's Pizzaria\" },\n      { $set: {\"_id\" : 4, \"violations\" : 7, \"borough\" : \"Manhattan\" } },\n      { upsert: true }\n   );\n} catch (e) {\n   print(e);\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{\n   \"acknowledged\" : true,\n   \"matchedCount\" : 0,\n   \"modifiedCount\" : 0,\n   \"upsertedId\" : 4\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 },\n{ \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 },\n{ \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 4 },\n{ \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"Borough\" : \"Manhattan\", \"violations\" : 7 }"
                },
                {
                    "lang": "javascript",
                    "value": "try {\n   db.restaurant.updateOne(\n      { \"violations\" : { $gt: 10} },\n      { $set: { \"Closed\" : true } },\n      { upsert: true }\n   );\n} catch (e) {\n   print(e);\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{\n   \"acknowledged\" : true,\n   \"matchedCount\" : 0,\n   \"modifiedCount\" : 0,\n   \"upsertedId\" : ObjectId(\"56310c3c0c5cbb6031cafaea\")\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 },\n{ \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 },\n{ \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 4 },\n{ \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"Borough\" : \"Manhattan\", \"grade\" : 7 }\n{ \"_id\" : ObjectId(\"56310c3c0c5cbb6031cafaea\"), \"Closed\" : true }"
                },
                {
                    "lang": "javascript",
                    "value": "try {\n   db.restaurant.updateOne(\n       { \"name\" : \"Pizza Rat's Pizzaria\" },\n       { $inc: { \"violations\" : 3}, $set: { \"Closed\" : true } },\n       { w: \"majority\", wtimeout: 100 }\n   );\n} catch (e) {\n   print(e);\n}"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 }"
                },
                {
                    "lang": "javascript",
                    "value": "WriteConcernError({\n   \"code\" : 64,\n   \"errmsg\" : \"waiting for replication timed out\",\n   \"errInfo\" : {\n     \"wtimeout\" : true,\n     \"writeConcern\" : {\n       \"w\" : \"majority\",\n       \"wtimeout\" : 100,\n       \"provenance\" : \"getLastErrorDefaults\"\n     }\n   }\n})"
                },
                {
                    "lang": "javascript",
                    "value": "{ _id: 1, category: \"caf\u00e9\", status: \"A\" }\n{ _id: 2, category: \"cafe\", status: \"a\" }\n{ _id: 3, category: \"cafE\", status: \"a\" }"
                },
                {
                    "lang": "javascript",
                    "value": "db.myColl.updateOne(\n   { category: \"cafe\" },\n   { $set: { status: \"Updated\" } },\n   { collation: { locale: \"fr\", strength: 1 } }\n);"
                },
                {
                    "lang": "javascript",
                    "value": "db.students.insertMany( [\n   { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] },\n   { \"_id\" : 2, \"grades\" : [ 98, 100, 102 ] },\n   { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] }\n] )"
                },
                {
                    "lang": "javascript",
                    "value": "db.students.updateOne(\n   { grades: { $gte: 100 } },\n   { $set: { \"grades.$[element]\" : 100 } },\n   { arrayFilters: [ { \"element\": { $gte: 100 } } ] }\n)"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] }\n{ \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] }\n{ \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] }"
                },
                {
                    "lang": "javascript",
                    "value": "db.students2.insertMany( [\n   {\n      \"_id\" : 1,\n      \"grades\" : [\n         { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 },\n         { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 },\n         { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 }\n      ]\n   },\n   {\n      \"_id\" : 2,\n      \"grades\" : [\n         { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 },\n         { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 },\n         { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 }\n      ]\n   }\n] )"
                },
                {
                    "lang": "javascript",
                    "value": "db.students2.updateOne(\n   { },\n   { $set: { \"grades.$[elem].mean\" : 100 } },\n   { arrayFilters: [ { \"elem.grade\": { $gte: 85 } } ] }\n)"
                },
                {
                    "lang": "javascript",
                    "value": "{\n   \"_id\" : 1,\n   \"grades\" : [\n      { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 },\n      { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 },\n      { \"grade\" : 85, \"mean\" : 100, \"std\" : 6 }\n    ]\n}\n{\n   \"_id\" : 2,\n   \"grades\" : [\n      { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 },\n      { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 },\n      { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 }\n   ]\n}"
                },
                {
                    "lang": "javascript",
                    "value": "db.members.insertMany( [\n   { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"P\", \"points\" :  0,  \"misc1\" : null, \"misc2\" : null },\n   { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60,  \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" },\n   { \"_id\" : 3, \"member\" : \"lmn123\", \"status\" : \"P\", \"points\" :  0,  \"misc1\" : null, \"misc2\" : null },\n   { \"_id\" : 4, \"member\" : \"pqr123\", \"status\" : \"D\", \"points\" : 20,  \"misc1\" : \"Deactivated\", \"misc2\" : null },\n   { \"_id\" : 5, \"member\" : \"ijk123\", \"status\" : \"P\", \"points\" :  0,  \"misc1\" : null, \"misc2\" : null },\n   { \"_id\" : 6, \"member\" : \"cde123\", \"status\" : \"A\", \"points\" : 86,  \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" }\n] )"
                },
                {
                    "lang": "javascript",
                    "value": "db.members.createIndex( { status: 1 } )\ndb.members.createIndex( { points: 1 } )"
                },
                {
                    "lang": "javascript",
                    "value": "db.members.updateOne(\n   { \"points\": { $lte: 20 }, \"status\": \"P\" },\n   { $set: { \"misc1\": \"Need to activate\" } },\n   { hint: { status: 1 } }\n)"
                },
                {
                    "lang": "javascript",
                    "value": "{ \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 }"
                },
                {
                    "lang": "javascript",
                    "value": "db.members.aggregate( [ { $indexStats: { } }, { $sort: { name: 1 } } ] )"
                }
            ],
            "preview": "implement this later",
            "tags": null
        },
        {
            "slug": "implement this later",
            "title": "Introduction to MongoDB",
            "headings": [
                "Document Database",
                "Collections/Views/On-Demand Materialized Views",
                "Key Features",
                "High Performance",
                "Query API",
                "High Availability",
                "Horizontal Scalability",
                "Support for Multiple Storage Engines"
            ],
            "paragraphs": "MongoDB 6.0 release candidates are not yet available.\nThis version of the manual is for an upcoming release and is\ncurrently a work in progress.A record in MongoDB is a document, which is a data structure composed\nof field and value pairs. MongoDB documents are similar to JSON\nobjects. The values of fields may include other documents, arrays,\nand arrays of documents.The advantages of using documents are:Documents correspond to native data types in many programming\nlanguages.Embedded documents and arrays reduce need for expensive joins.Dynamic schema supports fluent polymorphism.MongoDB stores documents in collections.\nCollections are analogous to tables in relational databases.In addition to collections, MongoDB supports:Read-only Views (Starting in MongoDB 3.4)On-Demand Materialized Views (Starting in MongoDB 4.2).MongoDB provides high performance data persistence. In particular,Support for embedded data models reduces I/O activity on database\nsystem.Indexes support faster queries and can include keys from embedded\ndocuments and arrays.The MongoDB Query API supports read and write\noperations (CRUD) as well as:Data AggregationText Search and Geospatial Queries.SQL to MongoDB Mapping ChartSQL to Aggregation Mapping ChartLearn about the latest query language features with the MongoDB\nQuery Language: What's New\npresentation from MongoDB.live 2020.MongoDB's replication facility, called replica set, provides:A replica set is a group of\nMongoDB servers that maintain the same data set, providing redundancy\nand increasing data availability.automatic failoverdata redundancy.MongoDB provides horizontal scalability as part of its core\nfunctionality:Sharding distributes data across a\ncluster of machines.Starting in 3.4, MongoDB supports creating zones of data based on the shard key. In a\nbalanced cluster, MongoDB directs reads and writes covered by a zone\nonly to those shards inside the zone. See the Zones\nmanual page for more information.MongoDB supports multiple storage engines:In addition, MongoDB provides pluggable storage engine API that allows\nthird parties to develop storage engines for MongoDB.WiredTiger Storage Engine (including support for\nEncryption at Rest)In-Memory Storage Engine.",
            "code": [],
            "preview": "implement this later",
            "tags": null
        },
        {
            "slug": "implement this later",
            "title": "logApplicationMessage",
            "headings": [],
            "paragraphs": "The logApplicationMessage command allows users to post\na custom message to the audit log. If\nrunning with authorization, users must have clusterAdmin\nrole, or roles that inherit from clusterAdmin, to run\nthe command.The logApplicationMessage has the following syntax:MongoDB associates these custom messages with the audit\noperation applicationMessage,\nand the messages are subject to any filtering.Available only in MongoDB Enterprise\nand MongoDB Atlas.",
            "code": [
                {
                    "lang": "javascript",
                    "value": "{ logApplicationMessage: <string> }"
                }
            ],
            "preview": "implement this later",
            "tags": null
        },
        [
            "robots=None in meta directive"
        ]
    ]
}